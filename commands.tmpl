// Glow automatically generated OpenGL binding: http://github.com/errcw/glow
//
// Copyright (c) 2010 Khronos Group.
// This material may be distributed subject to the terms and conditions
// set forth in the Open Publication License, v 1.0, 8 June 1999.
// http://opencontent.org/openpub/.
// 
// Copyright (c) 1991-2006 Silicon Graphics, Inc.
// This document is licensed under the SGI Free Software B License.
// For details, see http://oss.sgi.com/projects/FreeB.

package gl

{{define "paramsCDecl"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.Type.CType}} {{$p.CName}}{{end}}{{end}}
{{define "paramsCCall"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.CName}}{{end}}{{end}}
{{define "paramsGoDecl"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.GoName}} {{$p.Type.GoType}}{{end}}{{end}}
{{define "paramsGoCall"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.Type.ConvertGoToC}}({{$p.GoName}}){{end}}{{end}}

// #cgo darwin  LDFLAGS: -framework OpenGL
// #cgo linux   LDFLAGS: -lGL
// #cgo windows LDFLAGS: -lopengl32
//
// #ifndef APIENTRY
// #define APIENTRY
// #endif
// #ifndef APIENTRYP
// #define APIENTRYP APIENTRY *
// #endif
// #ifndef GLAPI
// #define GLAPI extern
// #endif
//
// {{range .Typedefs}}
// {{if ne .Name "khrplatform"}}{{replace .CDefinition "\n" "\n// " -1}}{{end}}
// {{end}}
//
// {{range .Functions}}
// typedef {{.Return.CType}} (APIENTRYP PGL{{toUpper .GoName}})({{template "paramsCDecl" .Parameters}});
// {{end}}
//
// {{range .Functions}}
// {{.Return.CType}} glow{{.GoName}}(PGL{{toUpper .GoName}} glfptr{{if ge (len .Parameters) 1}}, {{end}}{{template "paramsCDecl" .Parameters}}) {
//   {{if not .Return.IsVoid}}return {{end}}(*glfptr)({{template "paramsCCall" .Parameters}});
// }
// {{end}}
// 
import "C"
import "errors"
import "github.com/errcw/glow/glt"
import "github.com/errcw/glow/procaddr"
import "github.com/errcw/glow/procaddr/auto"
import "unsafe"

var (
  {{range .Functions}}
  pgl{{.GoName}} C.PGL{{toUpper .GoName}}
  {{end}}
)

// Conversion functions
func GLBoolean(b C.GLboolean) bool {
	return b == TRUE
}
func GoBoolean(b bool) C.GLboolean {
	if b { return TRUE }
	return FALSE
}
func cgoPtr1(p *glt.Pointer) *unsafe.Pointer {
	return (*unsafe.Pointer)(unsafe.Pointer(p))
}
func cgoChar2(p **int8) **C.GLchar {
	return (**C.GLchar)(unsafe.Pointer(p))
}

{{define "bridgeCall"}}C.glow{{.GoName}}(pgl{{.GoName}}{{if ge (len .Parameters) 1}}, {{end}}{{template "paramsGoCall" .Parameters}}){{end}}
{{range .Functions}}
// {{doc .GoName}}
func {{.GoName}}({{template "paramsGoDecl" .Parameters}}){{if not .Return.IsVoid}} {{.Return.GoType}}{{end}} {
  {{if .Return.IsVoid}}{{template "bridgeCall" .}}
  {{else}}return {{.Return.ConvertCToGo}}({{template "bridgeCall" .}}){{end}}
}
{{end}}

func Init() error {
  return InitWithProcAddrFunc(auto.GetProcAddress)
}

func InitWithProcAddrFunc(getProcAddr procaddr.GetProcAddressFunc) error {
  {{range .Functions}}
  if pgl{{.GoName}} = (C.PGL{{toUpper .GoName}})(unsafe.Pointer(getProcAddr("gl{{.GoName}}"))); pgl{{.GoName}} == nil {
    return errors.New("gl{{.GoName}}")
  }
  {{end}}
	return nil
}
