// Glow automatically generated OpenGL binding: http://github.com/errcw/glow
//
// Copyright (c) 2010 Khronos Group.
// This material may be distributed subject to the terms and conditions
// set forth in the Open Publication License, v 1.0, 8 June 1999.
// http://opencontent.org/openpub/.
// 
// Copyright (c) 1991-2006 Silicon Graphics, Inc.
// This document is licensed under the SGI Free Software B License.
// For details, see http://oss.sgi.com/projects/FreeB.

package {{.Name}}

{{define "paramsCDecl"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.Type.CType}} {{$p.CName}}{{end}}{{end}}
{{define "paramsCCall"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.CName}}{{end}}{{end}}
{{define "paramsGoDecl"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.GoName}} {{$p.Type.GoType}}{{end}}{{end}}
{{define "paramsGoCall"}}{{range $i, $p := .}}{{if ne $i 0}}, {{end}}{{$p.Type.ConvertGoToC}}({{$p.GoName}}){{end}}{{end}}

// #cgo darwin  LDFLAGS: -framework OpenGL
// #cgo linux   LDFLAGS: -lGL
// #cgo windows LDFLAGS: -lopengl32
//
// #ifndef APIENTRY
// #define APIENTRY
// #endif
// #ifndef APIENTRYP
// #define APIENTRYP APIENTRY *
// #endif
// #ifndef GLAPI
// #define GLAPI extern
// #endif
//
// {{range .Typedefs}}
// {{replace .CDefinition "\n" "\n// " -1}}
// {{end}}
//
// {{range .Groups}}{{if .Required}}
// {{range .Functions}}
// typedef {{.Return.CType}} (APIENTRYP P{{toUpper .GoName}})({{template "paramsCDecl" .Parameters}});
// {{end}}
// {{end}}{{end}}
//
// {{range .Groups}}{{if .Required}}
// {{range .Functions}}
// {{.Return.CType}} glow{{.GoName}}(P{{toUpper .GoName}} fnptr{{if ge (len .Parameters) 1}}, {{end}}{{template "paramsCDecl" .Parameters}}) {
//   {{if not .Return.IsVoid}}return {{end}}(*fnptr)({{template "paramsCCall" .Parameters}});
// }
// {{end}}
// {{end}}{{end}}
// 
import "C"
import "errors"
import "github.com/errcw/glow/glt"
import "github.com/errcw/glow/procaddr"
import "github.com/errcw/glow/procaddr/auto"
import "unsafe"

var (
  {{range .Groups}}{{if .Required}}
  {{range .Functions}}
  p{{.GoName}} C.P{{toUpper .GoName}}
  {{end}}
  {{end}}{{end}}
)

const (
  {{range .Groups}}{{if .Required}}
  {{range .Enums}}
  {{.GoName}} = {{.Value}}
  {{end}}
  {{end}}{{end}}
)

// Conversion functions
func GLBoolean(b C.GLboolean) bool {
	return b == TRUE
}
func GoBoolean(b bool) C.GLboolean {
	if b { return TRUE }
	return FALSE
}
func cgoPtr1(p *glt.Pointer) *unsafe.Pointer {
	return (*unsafe.Pointer)(unsafe.Pointer(p))
}
func cgoChar2(p **int8) **C.GLchar {
	return (**C.GLchar)(unsafe.Pointer(p))
}

{{define "bridgeCall"}}C.glow{{.GoName}}(p{{.GoName}}{{if ge (len .Parameters) 1}}, {{end}}{{template "paramsGoCall" .Parameters}}){{end}}
{{range .Groups}}{{if .Required}}
{{range .Functions}}
func {{.GoName}}({{template "paramsGoDecl" .Parameters}}){{if not .Return.IsVoid}} {{.Return.GoType}}{{end}} {
  {{if .Return.IsVoid}}{{template "bridgeCall" .}}
  {{else}}return {{.Return.ConvertCToGo}}({{template "bridgeCall" .}}){{end}}
}
{{end}}
{{end}}{{end}}

func Init() error {
  return InitWithProcAddrFunc(auto.GetProcAddress)
}

func InitWithProcAddrFunc(getProcAddr procaddr.GetProcAddressFunc) error {
  {{range .Groups}}{{if .Required}}
  {{range .Functions}}
  if p{{.GoName}} = (C.P{{toUpper .GoName}})(unsafe.Pointer(getProcAddr("gl{{.GoName}}"))); p{{.GoName}} == nil {
    return errors.New("gl{{.GoName}}")
  }
  {{end}}
  {{end}}{{end}}
	return nil
}
